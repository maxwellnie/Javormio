package io.github.maxwellnie.javormio.core.execution.statement;

import io.github.maxwellnie.javormio.core.execution.executor.parameter.ExecutableSql;
import io.github.maxwellnie.javormio.core.execution.ExecutionException;
import io.github.maxwellnie.javormio.core.execution.result.ResultParseException;
import io.github.maxwellnie.javormio.core.execution.result.ResultSetConvertor;
import io.github.maxwellnie.javormio.common.java.sql.SqlParameter;
import io.github.maxwellnie.javormio.common.java.sql.SqlType;
import io.github.maxwellnie.javormio.common.java.table.primary.KeyGenerator;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * @author Maxwell Nie
 */
public class PreparedStatementHelper implements StatementHelper<PreparedStatement> {
    private PreparedStatement getPreparedStatement(Connection connection, ExecutableSql executableSql) throws SQLException {
        PreparedStatement preparedStatement;
        if (executableSql.getSql() == null || executableSql.getSql().isEmpty())
            throw new ExecutionException("ExecutableSql sqlList is empty.");
        String sql = executableSql.getSql();
        if (SqlType.isInsert(executableSql.getType())) {
            KeyGenerator[] keyGenerators = executableSql.getKeyGenerators();
            if (keyGenerators != null && keyGenerators.length >= 1){
                boolean acceptGenerateKeys = false;
                for (KeyGenerator keyGenerator : keyGenerators) {
                    if (keyGenerator.isAcceptGenerateKeys()) {
                        acceptGenerateKeys = true;
                        break;
                    }
                }
                preparedStatement = createPreparedStatement(connection, acceptGenerateKeys, sql);
            } else
                preparedStatement = createPreparedStatement(connection, false, sql);
        } else {
            preparedStatement = createPreparedStatement(connection, false, sql);
        }
        return preparedStatement;
    }

    protected void setParameters(PreparedStatement preparedStatement, SqlParameter[] parameters) throws SQLException {
        for (int i = 0; i < parameters.length; i++) {
            SqlParameter parameter = parameters[i];
            parameter.getTypeHandler().setValue(preparedStatement, i + 1, parameter.getValue());
        }
    }
    protected PreparedStatement createPreparedStatement(Connection connection, boolean autoGeneratedKeys, String sql) throws SQLException {
        if (autoGeneratedKeys) {
            return connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
        } else {
            return connection.prepareStatement(sql);
        }
    }

    @Override
    public PreparedStatement createStatement(Connection connection, ExecutableSql executableSql) throws SQLException {
        PreparedStatement preparedStatement;
        preparedStatement = getPreparedStatement(connection, executableSql);
        if(executableSql.getParametersList() != null)
            for (SqlParameter[] parameters : executableSql.getParametersList())
                setParameters(preparedStatement, parameters);
        return preparedStatement;
    }

    @Override
    public PreparedStatement createBatchStatement(Connection connection, ExecutableSql executableSql) throws SQLException {
        PreparedStatement preparedStatement = getPreparedStatement(connection, executableSql);
        for (SqlParameter[] parameters : executableSql.getParametersList()) {
            setParameters(preparedStatement, parameters);
            preparedStatement.addBatch();
        }
        return preparedStatement;
    }

    @Override
    public int update(PreparedStatement statement) throws SQLException {
        return statement.executeUpdate();
    }

    @Override
    public int[] batchUpdate(PreparedStatement statement) throws SQLException {
        return statement.executeBatch();
    }

    @Override
    public <R> R query(ResultSetConvertor<R> convertor, PreparedStatement statement) throws ResultParseException, SQLException {
        statement.execute();
        return convertor.convert(statement);
    }

}
